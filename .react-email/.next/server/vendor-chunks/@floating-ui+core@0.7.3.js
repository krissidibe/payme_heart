"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui+core@0.7.3";
exports.ids = ["vendor-chunks/@floating-ui+core@0.7.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@floating-ui+core@0.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@floating-ui+core@0.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getMainAxisFromPlacement(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].includes(getSide(placement)) ? \"x\" : \"y\";\n}\nfunction getLengthFromAxis(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const mainAxis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(mainAxis);\n    const commonAlign = reference[length] / 2 - floating[length] / 2;\n    const side = getSide(placement);\n    const isVertical = mainAxis === \"x\";\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch(getAlignment(placement)){\n        case \"start\":\n            coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    if (true) {\n        if (platform == null) {\n            console.error([\n                \"Floating UI: `platform` property was not passed to config. If you\",\n                \"want to use Floating UI on the web, install @floating-ui/dom\",\n                \"instead of the /core package. Otherwise, you can create your own\",\n                \"`platform`: https://floating-ui.com/docs/platform\"\n            ].join(\" \"));\n        }\n        if (middleware.filter((_ref)=>{\n            let { name } = _ref;\n            return name === \"autoPlacement\" || name === \"flip\";\n        }).length > 1) {\n            throw new Error([\n                \"Floating UI: duplicate `flip` and/or `autoPlacement`\",\n                \"middleware detected. This will lead to an infinite loop. Ensure only\",\n                \"one of either has been passed to the `middleware` array.\"\n            ].join(\" \"));\n        }\n    }\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < middleware.length; i++){\n        const { name, fn } = middleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (true) {\n            if (resetCount > 50) {\n                console.warn([\n                    \"Floating UI: The middleware lifecycle appears to be running in an\",\n                    \"infinite loop. This is usually caused by a `reset` continually\",\n                    \"being returned without a break condition.\"\n                ].join(\" \"));\n            }\n        }\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n            continue;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getSideObjectFromPadding(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    return {\n        ...rect,\n        top: rect.y,\n        left: rect.x,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(middlewareArguments, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = middlewareArguments;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = options;\n    const paddingObject = getSideObjectFromPadding(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: elementContext === \"floating\" ? {\n            ...rects.floating,\n            x,\n            y\n        } : rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n    }) : rects[elementContext]);\n    return {\n        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n        right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n}\nconst min = Math.min;\nconst max = Math.max;\nfunction within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n}\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (middlewareArguments) {\n            // Since `element` is required, we don't Partial<> the type\n            const { element, padding = 0 } = options != null ? options : {};\n            const { x, y, placement, rects, platform } = middlewareArguments;\n            if (element == null) {\n                if (true) {\n                    console.warn(\"Floating UI: No `element` was passed to the `arrow` middleware.\");\n                }\n                return {};\n            }\n            const paddingObject = getSideObjectFromPadding(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = getMainAxisFromPlacement(placement);\n            const alignment = getAlignment(placement);\n            const length = getLengthFromAxis(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const minProp = axis === \"y\" ? \"top\" : \"left\";\n            const maxProp = axis === \"y\" ? \"bottom\" : \"right\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n            if (clientSize === 0) {\n                clientSize = rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds\n            const min = paddingObject[minProp];\n            const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = within(min, center, max); // Make sure that arrow points at the reference\n            const alignmentPadding = alignment === \"start\" ? paddingObject[minProp] : paddingObject[maxProp];\n            const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n            const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n            return {\n                [axis]: coords[axis] - alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset\n                }\n            };\n        }\n    });\nconst hash$1 = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (matched)=>hash$1[matched]);\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const mainAxis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(mainAxis);\n    let mainAlignmentSide = mainAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return {\n        main: mainAlignmentSide,\n        cross: getOppositePlacement(mainAlignmentSide)\n    };\n}\nconst hash = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (matched)=>hash[matched]);\n}\nconst sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst allPlacements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-start\", side + \"-end\"), []);\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>getAlignment(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>getAlignment(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>getSide(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (middlewareArguments) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n            const { x, y, rects, middlewareData, placement, platform, elements } = middlewareArguments;\n            const { alignment = null, allowedPlacements = allPlacements, autoAlignment = true, ...detectOverflowOptions } = options;\n            const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n            const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n            const currentPlacement = placements[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const { main, cross } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n            if (placement !== currentPlacement) {\n                return {\n                    x,\n                    y,\n                    reset: {\n                        placement: placements[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[getSide(currentPlacement)],\n                overflow[main],\n                overflow[cross]\n            ];\n            const allOverflows = [\n                ...(_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b)=>a.overflows[0] - b.overflows[0]);\n            const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref)=>{\n                let { overflows } = _ref;\n                return overflows.every((overflow)=>overflow <= 0);\n            })) == null ? void 0 : _placementsSortedByLe.placement;\n            const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (middlewareArguments) {\n            var _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = middlewareArguments;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", flipAlignment = true, ...detectOverflowOptions } = options;\n            const side = getSide(placement);\n            const isBasePlacement = side === initialPlacement;\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                getOppositePlacement(initialPlacement)\n            ] : getExpandedPlacements(initialPlacement));\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const { main, cross } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n                overflows.push(overflow[main], overflow[cross]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ]; // One or more sides is overflowing\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip$, _middlewareData$flip2;\n                const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    // Try next placement and re-run the lifecycle\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                let resetPlacement = \"bottom\";\n                switch(fallbackStrategy){\n                    case \"bestFit\":\n                        {\n                            var _overflowsData$map$so;\n                            const placement = (_overflowsData$map$so = overflowsData.map((d)=>[\n                                    d,\n                                    d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n                            if (placement) {\n                                resetPlacement = placement;\n                            }\n                            break;\n                        }\n                    case \"initialPlacement\":\n                        resetPlacement = initialPlacement;\n                        break;\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(_temp) {\n    let { strategy = \"referenceHidden\", ...detectOverflowOptions } = _temp === void 0 ? {} : _temp;\n    return {\n        name: \"hide\",\n        async fn (middlewareArguments) {\n            const { rects } = middlewareArguments;\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(middlewareArguments, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(middlewareArguments, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nasync function convertValueToCoords(middlewareArguments, value) {\n    const { placement, platform, elements } = middlewareArguments;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = getSide(placement);\n    const alignment = getAlignment(placement);\n    const isVertical = getMainAxisFromPlacement(placement) === \"x\";\n    const mainAxisMulti = [\n        \"left\",\n        \"top\"\n    ].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = typeof value === \"function\" ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        alignmentAxis: null,\n        ...rawValue\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(value) {\n    if (value === void 0) {\n        value = 0;\n    }\n    return {\n        name: \"offset\",\n        options: value,\n        async fn (middlewareArguments) {\n            const { x, y } = middlewareArguments;\n            const diffCoords = await convertValueToCoords(middlewareArguments, value);\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: diffCoords\n            };\n        }\n    };\n};\nfunction getCrossAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (middlewareArguments) {\n            const { x, y, placement } = middlewareArguments;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = options;\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n            const mainAxis = getMainAxisFromPlacement(getSide(placement));\n            const crossAxis = getCrossAxis(mainAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = within(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = within(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...middlewareArguments,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (middlewareArguments) {\n            const { x, y, placement, rects, middlewareData } = middlewareArguments;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = options;\n            const coords = {\n                x,\n                y\n            };\n            const mainAxis = getMainAxisFromPlacement(placement);\n            const crossAxis = getCrossAxis(mainAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = typeof offset === \"function\" ? offset({\n                ...rects,\n                placement\n            }) : offset;\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes(getSide(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (middlewareArguments) {\n            const { placement, rects, platform, elements } = middlewareArguments;\n            const { apply, ...detectOverflowOptions } = options;\n            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n            const side = getSide(placement);\n            const alignment = getAlignment(placement);\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const xMin = max(overflow.left, 0);\n            const xMax = max(overflow.right, 0);\n            const yMin = max(overflow.top, 0);\n            const yMax = max(overflow.bottom, 0);\n            const dimensions = {\n                availableHeight: rects.floating.height - ([\n                    \"left\",\n                    \"right\"\n                ].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n                availableWidth: rects.floating.width - ([\n                    \"top\",\n                    \"bottom\"\n                ].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n            };\n            const prevDimensions = await platform.getDimensions(elements.floating);\n            apply == null ? void 0 : apply({\n                ...middlewareArguments,\n                ...dimensions\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (middlewareArguments) {\n            var _await$platform$getCl;\n            const { placement, elements, rects, platform, strategy } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = options;\n            const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n                rect: rects.reference,\n                offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n                strategy\n            }) : rects.reference);\n            const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n            const paddingObject = getSideObjectFromPadding(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    var _clientRects$find;\n                    // Find the first rect in which the point is fully inside\n                    return (_clientRects$find = clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n                } // There are 2 or more connected rects\n                if (clientRects.length >= 2) {\n                    if (getMainAxisFromPlacement(placement) === \"x\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = getSide(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = getSide(placement) === \"left\";\n                    const maxRight = max(...clientRects.map((rect)=>rect.right));\n                    const minLeft = min(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZsb2F0aW5nLXVpK2NvcmVAMC43LjMvbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsUUFBUUMsU0FBUztJQUN4QixPQUFPQSxVQUFVQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDaEM7QUFFQSxTQUFTQyxhQUFhRixTQUFTO0lBQzdCLE9BQU9BLFVBQVVDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNoQztBQUVBLFNBQVNFLHlCQUF5QkgsU0FBUztJQUN6QyxPQUFPO1FBQUM7UUFBTztLQUFTLENBQUNJLFFBQVEsQ0FBQ0wsUUFBUUMsY0FBYyxNQUFNO0FBQ2hFO0FBRUEsU0FBU0ssa0JBQWtCQyxJQUFJO0lBQzdCLE9BQU9BLFNBQVMsTUFBTSxXQUFXO0FBQ25DO0FBRUEsU0FBU0MsMkJBQTJCQyxJQUFJLEVBQUVSLFNBQVMsRUFBRVMsR0FBRztJQUN0RCxJQUFJLEVBQ0ZDLFNBQVMsRUFDVEMsUUFBUSxFQUNULEdBQUdIO0lBQ0osTUFBTUksVUFBVUYsVUFBVUcsQ0FBQyxHQUFHSCxVQUFVSSxLQUFLLEdBQUcsSUFBSUgsU0FBU0csS0FBSyxHQUFHO0lBQ3JFLE1BQU1DLFVBQVVMLFVBQVVNLENBQUMsR0FBR04sVUFBVU8sTUFBTSxHQUFHLElBQUlOLFNBQVNNLE1BQU0sR0FBRztJQUN2RSxNQUFNQyxXQUFXZix5QkFBeUJIO0lBQzFDLE1BQU1tQixTQUFTZCxrQkFBa0JhO0lBQ2pDLE1BQU1FLGNBQWNWLFNBQVMsQ0FBQ1MsT0FBTyxHQUFHLElBQUlSLFFBQVEsQ0FBQ1EsT0FBTyxHQUFHO0lBQy9ELE1BQU1FLE9BQU90QixRQUFRQztJQUNyQixNQUFNc0IsYUFBYUosYUFBYTtJQUNoQyxJQUFJSztJQUVKLE9BQVFGO1FBQ04sS0FBSztZQUNIRSxTQUFTO2dCQUNQVixH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O2dCQUMzQmU7WUFDRjtZQUVBLElBQUlXLE1BQU0zQixTQUFTLENBQUNHLENBQUMsS0FBSzZOLFdBQVdoTyxTQUFTLENBQUNHLENBQUMsSUFBSXdCLE1BQU0zQixTQUFTLENBQUNNLENBQUMsS0FBSzBOLFdBQVdoTyxTQUFTLENBQUNNLENBQUMsSUFBSXFCLE1BQU0zQixTQUFTLENBQUNJLEtBQUssS0FBSzROLFdBQVdoTyxTQUFTLENBQUNJLEtBQUssSUFBSXVCLE1BQU0zQixTQUFTLENBQUNPLE1BQU0sS0FBS3lOLFdBQVdoTyxTQUFTLENBQUNPLE1BQU0sRUFBRTtnQkFDbE4sT0FBTztvQkFDTDhCLE9BQU87d0JBQ0xWLE9BQU9xTTtvQkFDVDtnQkFDRjtZQUNGO1lBRUEsT0FBTyxDQUFDO1FBQ1Y7SUFFRjtBQUNGO0FBRXdJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwtY2xpZW50Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BmbG9hdGluZy11aStjb3JlQDAuNy4zL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvY29yZS9kaXN0L2Zsb2F0aW5nLXVpLmNvcmUubWpzPzgyMWYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/ICd4JyA6ICd5Jztcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoRnJvbUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRMZW5ndGhGcm9tQXhpcyhtYWluQXhpcyk7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gZmxvYXRpbmdbbGVuZ3RoXSAvIDI7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBtYWluQXhpcyA9PT0gJ3gnO1xuICBsZXQgY29vcmRzO1xuXG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICBzd2l0Y2ggKGdldEFsaWdubWVudChwbGFjZW1lbnQpKSB7XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgY29vcmRzW21haW5BeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2VuZCc6XG4gICAgICBjb29yZHNbbWFpbkF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgcmVmZXJlbmNlIGVsZW1lbnQgd2hlbiBpdCBpcyBnaXZlbiBhIGNlcnRhaW4gcG9zaXRpb25pbmcgc3RyYXRlZ3kuXG4gKlxuICogVGhpcyBleHBvcnQgZG9lcyBub3QgaGF2ZSBhbnkgYHBsYXRmb3JtYCBpbnRlcmZhY2UgbG9naWMuIFlvdSB3aWxsIG5lZWQgdG9cbiAqIHdyaXRlIG9uZSBmb3IgdGhlIHBsYXRmb3JtIHlvdSBhcmUgdXNpbmcgRmxvYXRpbmcgVUkgd2l0aC5cbiAqL1xuXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHBsYXRmb3JtID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydGbG9hdGluZyBVSTogYHBsYXRmb3JtYCBwcm9wZXJ0eSB3YXMgbm90IHBhc3NlZCB0byBjb25maWcuIElmIHlvdScsICd3YW50IHRvIHVzZSBGbG9hdGluZyBVSSBvbiB0aGUgd2ViLCBpbnN0YWxsIEBmbG9hdGluZy11aS9kb20nLCAnaW5zdGVhZCBvZiB0aGUgL2NvcmUgcGFja2FnZS4gT3RoZXJ3aXNlLCB5b3UgY2FuIGNyZWF0ZSB5b3VyIG93bicsICdgcGxhdGZvcm1gOiBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3BsYXRmb3JtJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICBpZiAobWlkZGxld2FyZS5maWx0ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBuYW1lXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBuYW1lID09PSAnYXV0b1BsYWNlbWVudCcgfHwgbmFtZSA9PT0gJ2ZsaXAnO1xuICAgIH0pLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbJ0Zsb2F0aW5nIFVJOiBkdXBsaWNhdGUgYGZsaXBgIGFuZC9vciBgYXV0b1BsYWNlbWVudGAnLCAnbWlkZGxld2FyZSBkZXRlY3RlZC4gVGhpcyB3aWxsIGxlYWQgdG8gYW4gaW5maW5pdGUgbG9vcC4gRW5zdXJlIG9ubHknLCAnb25lIG9mIGVpdGhlciBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIGBtaWRkbGV3YXJlYCBhcnJheS4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSBtaWRkbGV3YXJlW2ldO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IG5leHRYLFxuICAgICAgeTogbmV4dFksXG4gICAgICBkYXRhLFxuICAgICAgcmVzZXRcbiAgICB9ID0gYXdhaXQgZm4oe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBpbml0aWFsUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSk7XG4gICAgeCA9IG5leHRYICE9IG51bGwgPyBuZXh0WCA6IHg7XG4gICAgeSA9IG5leHRZICE9IG51bGwgPyBuZXh0WSA6IHk7XG4gICAgbWlkZGxld2FyZURhdGEgPSB7IC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7IC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyZXNldENvdW50ID4gNTApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFsnRmxvYXRpbmcgVUk6IFRoZSBtaWRkbGV3YXJlIGxpZmVjeWNsZSBhcHBlYXJzIHRvIGJlIHJ1bm5pbmcgaW4gYW4nLCAnaW5maW5pdGUgbG9vcC4gVGhpcyBpcyB1c3VhbGx5IGNhdXNlZCBieSBhIGByZXNldGAgY29udGludWFsbHknLCAnYmVpbmcgcmV0dXJuZWQgd2l0aG91dCBhIGJyZWFrIGNvbmRpdGlvbi4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZXNldC5wbGFjZW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZWZ1bFBsYWNlbWVudCA9IHJlc2V0LnBsYWNlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cblxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cblxuICAgICAgaSA9IC0xO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nKHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4geyAuLi5yZWN0LFxuICAgIHRvcDogcmVjdC55LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIG9wdGlvbnMpIHtcbiAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcblxuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgY29uc3Qge1xuICAgIGJvdW5kYXJ5ID0gJ2NsaXBwaW5nQW5jZXN0b3JzJyxcbiAgICByb290Qm91bmRhcnkgPSAndmlld3BvcnQnLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gJ2Zsb2F0aW5nJyxcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nKHBhZGRpbmcpO1xuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyAncmVmZXJlbmNlJyA6ICdmbG9hdGluZyc7XG4gIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoYXdhaXQgcGxhdGZvcm0uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAoKF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA9IGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChlbGVtZW50KSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kaXNFbGUgOiB0cnVlKSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IChhd2FpdCAocGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0pKTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIHJlY3Q6IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8geyAuLi5yZWN0cy5mbG9hdGluZyxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA6IHJlY3RzLnJlZmVyZW5jZSxcbiAgICBvZmZzZXRQYXJlbnQ6IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpLFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdHNbZWxlbWVudENvbnRleHRdKTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xufVxuXG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuXG5mdW5jdGlvbiB3aXRoaW4obWluJDEsIHZhbHVlLCBtYXgkMSkge1xuICByZXR1cm4gbWF4KG1pbiQxLCBtaW4odmFsdWUsIG1heCQxKSk7XG59XG5cbi8qKlxuICogUG9zaXRpb25zIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc3VjaCB0aGF0IGl0IGlzIGNlbnRlcmVkXG4gKiB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIG9wdGlvbnMsXG5cbiAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgIC8vIFNpbmNlIGBlbGVtZW50YCBpcyByZXF1aXJlZCwgd2UgZG9uJ3QgUGFydGlhbDw+IHRoZSB0eXBlXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm1cbiAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGbG9hdGluZyBVSTogTm8gYGVsZW1lbnRgIHdhcyBwYXNzZWQgdG8gdGhlIGBhcnJvd2AgbWlkZGxld2FyZS4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRTaWRlT2JqZWN0RnJvbVBhZGRpbmcocGFkZGluZyk7XG4gICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRMZW5ndGhGcm9tQXhpcyhheGlzKTtcbiAgICBjb25zdCBhcnJvd0RpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIGNvbnN0IG1pblByb3AgPSBheGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICBjb25zdCBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgIGNvbnN0IGVuZERpZmYgPSByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSArIHJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIGNvb3Jkc1theGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3Qgc3RhcnREaWZmID0gY29vcmRzW2F4aXNdIC0gcmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpKTtcbiAgICBsZXQgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcblxuICAgIGlmIChjbGllbnRTaXplID09PSAwKSB7XG4gICAgICBjbGllbnRTaXplID0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzXG5cbiAgICBjb25zdCBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICAgIGNvbnN0IG1heCA9IGNsaWVudFNpemUgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gICAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgICBjb25zdCBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIE1ha2Ugc3VyZSB0aGF0IGFycm93IHBvaW50cyBhdCB0aGUgcmVmZXJlbmNlXG5cbiAgICBjb25zdCBhbGlnbm1lbnRQYWRkaW5nID0gYWxpZ25tZW50ID09PSAnc3RhcnQnID8gcGFkZGluZ09iamVjdFttaW5Qcm9wXSA6IHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gYWxpZ25tZW50UGFkZGluZyA+IDAgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPD0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4gPyBtaW4gLSBjZW50ZXIgOiBtYXggLSBjZW50ZXIgOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59KTtcblxuY29uc3QgaGFzaCQxID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIG1hdGNoZWQgPT4gaGFzaCQxW21hdGNoZWRdKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG5cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldExlbmd0aEZyb21BeGlzKG1haW5BeGlzKTtcbiAgbGV0IG1haW5BbGlnbm1lbnRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcblxuICBpZiAocmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPiByZWN0cy5mbG9hdGluZ1tsZW5ndGhdKSB7XG4gICAgbWFpbkFsaWdubWVudFNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1haW46IG1haW5BbGlnbm1lbnRTaWRlLFxuICAgIGNyb3NzOiBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSlcbiAgfTtcbn1cblxuY29uc3QgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdKTtcbn1cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxsUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9zaWRlcy5yZWR1Y2UoKGFjYywgc2lkZSkgPT4gYWNjLmNvbmNhdChzaWRlLCBzaWRlICsgXCItc3RhcnRcIiwgc2lkZSArIFwiLWVuZFwiKSwgW10pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBjaG9vc2VzIHRoZSBgcGxhY2VtZW50YCB3aGljaCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhdXRvUGxhY2VtZW50JyxcbiAgICBvcHRpb25zLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMywgX21pZGRsZXdhcmVEYXRhJGF1dG9QNCwgX3BsYWNlbWVudHNTb3J0ZWRCeUxlO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGlnbm1lbnQgPSBudWxsLFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IGFsbFBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cyk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSAoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5pbmRleCkgIT0gbnVsbCA/IF9taWRkbGV3YXJlRGF0YSRhdXRvUCA6IDA7XG4gICAgICBjb25zdCBjdXJyZW50UGxhY2VtZW50ID0gcGxhY2VtZW50c1tjdXJyZW50SW5kZXhdO1xuXG4gICAgICBpZiAoY3VycmVudFBsYWNlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluLFxuICAgICAgICBjcm9zc1xuICAgICAgfSA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpOyAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZVxuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudHNbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvd3MgPSBbb3ZlcmZsb3dbZ2V0U2lkZShjdXJyZW50UGxhY2VtZW50KV0sIG92ZXJmbG93W21haW5dLCBvdmVyZmxvd1tjcm9zc11dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoX21pZGRsZXdhcmVEYXRhJGF1dG9QMyA9IChfbWlkZGxld2FyZURhdGEkYXV0b1A0ID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUDQub3ZlcmZsb3dzKSAhPSBudWxsID8gX21pZGRsZXdhcmVEYXRhJGF1dG9QMyA6IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tjdXJyZW50SW5kZXggKyAxXTsgLy8gVGhlcmUgYXJlIG1vcmUgcGxhY2VtZW50cyB0byBjaGVja1xuXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBsYWNlbWVudHNTb3J0ZWRCeUxlYXN0T3ZlcmZsb3cgPSBhbGxPdmVyZmxvd3Muc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLm92ZXJmbG93c1swXSAtIGIub3ZlcmZsb3dzWzBdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudFRoYXRGaXRzT25BbGxTaWRlcyA9IChfcGxhY2VtZW50c1NvcnRlZEJ5TGUgPSBwbGFjZW1lbnRzU29ydGVkQnlMZWFzdE92ZXJmbG93LmZpbmQoX3JlZiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgb3ZlcmZsb3dzXG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gb3ZlcmZsb3dzLmV2ZXJ5KG92ZXJmbG93ID0+IG92ZXJmbG93IDw9IDApO1xuICAgICAgfSkpID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1NvcnRlZEJ5TGUucGxhY2VtZW50O1xuICAgICAgY29uc3QgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnRUaGF0Rml0c09uQWxsU2lkZXMgIT0gbnVsbCA/IHBsYWNlbWVudFRoYXRGaXRzT25BbGxTaWRlcyA6IHBsYWNlbWVudHNTb3J0ZWRCeUxlYXN0T3ZlcmZsb3dbMF0ucGxhY2VtZW50O1xuXG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBwbGFjZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgdG8gb25lIHRoYXQgd2lsbCBmaXQgaWYgdGhlXG4gKiBpbml0aWFsbHkgc3BlY2lmaWVkIGBwbGFjZW1lbnRgIGRvZXMgbm90LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gc2lkZSA9PT0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwQWxpZ25tZW50ID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KGluaXRpYWxQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuXG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWFpbixcbiAgICAgICAgICBjcm9zc1xuICAgICAgICB9ID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbbWFpbl0sIG92ZXJmbG93W2Nyb3NzXSk7XG4gICAgICB9XG5cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07IC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nXG5cbiAgICAgIGlmICghb3ZlcmZsb3dzLmV2ZXJ5KHNpZGUgPT4gc2lkZSA8PSAwKSkge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXAkLCBfbWlkZGxld2FyZURhdGEkZmxpcDI7XG5cbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCQgPSAoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgIT0gbnVsbCA/IF9taWRkbGV3YXJlRGF0YSRmbGlwJCA6IDApICsgMTtcbiAgICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbbmV4dEluZGV4XTtcblxuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGVcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gJ2JvdHRvbSc7XG5cbiAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRtYXAkc287XG5cbiAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJG1hcCRzbyA9IG92ZXJmbG93c0RhdGEubWFwKGQgPT4gW2QsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkbWFwJHNvWzBdLnBsYWNlbWVudDtcblxuICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQsXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGZ1bmN0aW9uIChfdGVtcCkge1xuICBsZXQge1xuICAgIHN0cmF0ZWd5ID0gJ3JlZmVyZW5jZUhpZGRlbicsXG4gICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaGlkZScsXG5cbiAgICBhc3luYyBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcblxuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3cobWlkZGxld2FyZUFyZ3VtZW50cywgeyAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW46IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIHsgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9O1xufTtcblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMobWlkZGxld2FyZUFyZ3VtZW50cywgdmFsdWUpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpID09PSAneCc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBbJ2xlZnQnLCAndG9wJ10uaW5jbHVkZXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUobWlkZGxld2FyZUFyZ3VtZW50cykgOiB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuXG4gIGxldCB7XG4gICAgbWFpbkF4aXMsXG4gICAgY3Jvc3NBeGlzLFxuICAgIGFsaWdubWVudEF4aXNcbiAgfSA9IHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHJhd1ZhbHVlLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsXG4gIH0gOiB7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGwsXG4gICAgLi4ucmF3VmFsdWVcbiAgfTtcblxuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG5cbiAgcmV0dXJuIGlzVmVydGljYWwgPyB7XG4gICAgeDogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGksXG4gICAgeTogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpXG4gIH0gOiB7XG4gICAgeDogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpLFxuICAgIHk6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpXG4gIH07XG59XG4vKipcbiAqIERpc3BsYWNlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCBmcm9tIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICB2YWx1ZSA9IDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgIG9wdGlvbnM6IHZhbHVlLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhtaWRkbGV3YXJlQXJndW1lbnRzLCB2YWx1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiBkaWZmQ29vcmRzXG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Q3Jvc3NBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn1cblxuLyoqXG4gKiBTaGlmdHMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvd1xuICogYSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaGlmdCcsXG4gICAgb3B0aW9ucyxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGxpbWl0ZXIgPSB7XG4gICAgICAgICAgZm46IF9yZWYgPT4ge1xuICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3cobWlkZGxld2FyZUFyZ3VtZW50cywgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRDcm9zc0F4aXMobWFpbkF4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG5cbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IHdpdGhpbihtaW4sIG1haW5BeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IHdpdGhpbihtaW4sIGNyb3NzQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7IC4uLm1pZGRsZXdhcmVBcmd1bWVudHMsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gIH07XG59O1xuXG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcblxuICAgIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRDcm9zc0F4aXMobWFpbkF4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KHsgLi4ucmVjdHMsXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSkgOiBvZmZzZXQ7XG4gICAgICBjb25zdCBjb21wdXRlZE9mZnNldCA9IHR5cGVvZiByYXdPZmZzZXQgPT09ICdudW1iZXInID8ge1xuICAgICAgICBtYWluQXhpczogcmF3T2Zmc2V0LFxuICAgICAgICBjcm9zc0F4aXM6IDBcbiAgICAgIH0gOiB7XG4gICAgICAgIG1haW5BeGlzOiAwLFxuICAgICAgICBjcm9zc0F4aXM6IDAsXG4gICAgICAgIC4uLnJhd09mZnNldFxuICAgICAgfTtcblxuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuXG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkb2Zmc2UyLCBfbWlkZGxld2FyZURhdGEkb2Zmc2UzLCBfbWlkZGxld2FyZURhdGEkb2Zmc2U0O1xuXG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFsndG9wJywgJ2xlZnQnXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pICE9IG51bGwgPyBfbWlkZGxld2FyZURhdGEkb2Zmc2UgOiAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKF9taWRkbGV3YXJlRGF0YSRvZmZzZTMgPSAoX21pZGRsZXdhcmVEYXRhJG9mZnNlNCA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZTRbY3Jvc3NBeGlzXSkgIT0gbnVsbCA/IF9taWRkbGV3YXJlRGF0YSRvZmZzZTMgOiAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcblxuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudC4gRm9yIGluc3RhbmNlLFxuICogcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIGl0cyBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGUgd2lkdGggb2YgdGhlXG4gKiByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2l6ZScsXG4gICAgb3B0aW9ucyxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHksXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gICAgICBsZXQgaGVpZ2h0U2lkZTtcbiAgICAgIGxldCB3aWR0aFNpZGU7XG5cbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgeE1pbiA9IG1heChvdmVyZmxvdy5sZWZ0LCAwKTtcbiAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgY29uc3QgeU1heCA9IG1heChvdmVyZmxvdy5ib3R0b20sIDApO1xuICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0OiByZWN0cy5mbG9hdGluZy5oZWlnaHQgLSAoWydsZWZ0JywgJ3JpZ2h0J10uaW5jbHVkZXMocGxhY2VtZW50KSA/IDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKSA6IG92ZXJmbG93W2hlaWdodFNpZGVdKSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGg6IHJlY3RzLmZsb2F0aW5nLndpZHRoIC0gKFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKHBsYWNlbWVudCkgPyAyICogKHhNaW4gIT09IDAgfHwgeE1heCAhPT0gMCA/IHhNaW4gKyB4TWF4IDogbWF4KG92ZXJmbG93LmxlZnQsIG92ZXJmbG93LnJpZ2h0KSkgOiBvdmVyZmxvd1t3aWR0aFNpZGVdKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHByZXZEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50cy5mbG9hdGluZyk7XG4gICAgICBhcHBseSA9PSBudWxsID8gdm9pZCAwIDogYXBwbHkoeyAuLi5taWRkbGV3YXJlQXJndW1lbnRzLFxuICAgICAgICAuLi5kaW1lbnNpb25zXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5leHREaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50cy5mbG9hdGluZyk7XG5cbiAgICAgIGlmIChwcmV2RGltZW5zaW9ucy53aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgcHJldkRpbWVuc2lvbnMuaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdpbmxpbmUnLFxuICAgIG9wdGlvbnMsXG5cbiAgICBhc3luYyBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICB2YXIgX2F3YWl0JHBsYXRmb3JtJGdldENsO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzOyAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cblxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QocGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCh7XG4gICAgICAgIHJlY3Q6IHJlY3RzLnJlZmVyZW5jZSxcbiAgICAgICAgb2Zmc2V0UGFyZW50OiBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pIDogcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gKF9hd2FpdCRwbGF0Zm9ybSRnZXRDbCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMoZWxlbWVudHMucmVmZXJlbmNlKSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kZ2V0Q2wgOiBbXTtcbiAgICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRTaWRlT2JqZWN0RnJvbVBhZGRpbmcocGFkZGluZyk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0ICYmIHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2NsaWVudFJlY3RzJGZpbmQ7XG5cbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByZWN0IGluIHdoaWNoIHRoZSBwb2ludCBpcyBmdWxseSBpbnNpZGVcbiAgICAgICAgICByZXR1cm4gKF9jbGllbnRSZWN0cyRmaW5kID0gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSkgIT0gbnVsbCA/IF9jbGllbnRSZWN0cyRmaW5kIDogZmFsbGJhY2s7XG4gICAgICAgIH0gLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHNcblxuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpc1RvcCA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNldFJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBlbGVtZW50cy5mbG9hdGluZyxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcmVjdFRvQ2xpZW50UmVjdCwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6WyJnZXRTaWRlIiwicGxhY2VtZW50Iiwic3BsaXQiLCJnZXRBbGlnbm1lbnQiLCJnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQiLCJpbmNsdWRlcyIsImdldExlbmd0aEZyb21BeGlzIiwiYXhpcyIsImNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50IiwiX3JlZiIsInJ0bCIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwiY29tbW9uWCIsIngiLCJ3aWR0aCIsImNvbW1vblkiLCJ5IiwiaGVpZ2h0IiwibWFpbkF4aXMiLCJsZW5ndGgiLCJjb21tb25BbGlnbiIsInNpZGUiLCJpc1ZlcnRpY2FsIiwiY29vcmRzIiwiY29tcHV0ZVBvc2l0aW9uIiwiY29uZmlnIiwic3RyYXRlZ3kiLCJtaWRkbGV3YXJlIiwicGxhdGZvcm0iLCJpc1JUTCIsInByb2Nlc3MiLCJjb25zb2xlIiwiZXJyb3IiLCJqb2luIiwiZmlsdGVyIiwibmFtZSIsIkVycm9yIiwicmVjdHMiLCJnZXRFbGVtZW50UmVjdHMiLCJzdGF0ZWZ1bFBsYWNlbWVudCIsIm1pZGRsZXdhcmVEYXRhIiwicmVzZXRDb3VudCIsImkiLCJmbiIsIm5leHRYIiwibmV4dFkiLCJkYXRhIiwicmVzZXQiLCJpbml0aWFsUGxhY2VtZW50IiwiZWxlbWVudHMiLCJ3YXJuIiwiZXhwYW5kUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJnZXRTaWRlT2JqZWN0RnJvbVBhZGRpbmciLCJyZWN0VG9DbGllbnRSZWN0IiwicmVjdCIsImRldGVjdE92ZXJmbG93IiwibWlkZGxld2FyZUFyZ3VtZW50cyIsIm9wdGlvbnMiLCJfYXdhaXQkcGxhdGZvcm0kaXNFbGUiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsImVsZW1lbnRDb250ZXh0IiwiYWx0Qm91bmRhcnkiLCJwYWRkaW5nT2JqZWN0IiwiYWx0Q29udGV4dCIsImVsZW1lbnQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJnZXRDbGlwcGluZ1JlY3QiLCJpc0VsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldERvY3VtZW50RWxlbWVudCIsImVsZW1lbnRDbGllbnRSZWN0IiwiY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QiLCJvZmZzZXRQYXJlbnQiLCJnZXRPZmZzZXRQYXJlbnQiLCJtaW4iLCJNYXRoIiwibWF4Iiwid2l0aGluIiwibWluJDEiLCJ2YWx1ZSIsIm1heCQxIiwiYXJyb3ciLCJhbGlnbm1lbnQiLCJhcnJvd0RpbWVuc2lvbnMiLCJnZXREaW1lbnNpb25zIiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsImFsaWdubWVudFBhZGRpbmciLCJzaG91bGRBZGRPZmZzZXQiLCJhbGlnbm1lbnRPZmZzZXQiLCJjZW50ZXJPZmZzZXQiLCJoYXNoJDEiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsInJlcGxhY2UiLCJtYXRjaGVkIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJtYWluQWxpZ25tZW50U2lkZSIsIm1haW4iLCJjcm9zcyIsImhhc2giLCJzdGFydCIsImVuZCIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50Iiwic2lkZXMiLCJhbGxQbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwiY29uY2F0IiwiZ2V0UGxhY2VtZW50TGlzdCIsImF1dG9BbGlnbm1lbnQiLCJhbGxvd2VkUGxhY2VtZW50cyIsImFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQiLCJhdXRvUGxhY2VtZW50IiwiX21pZGRsZXdhcmVEYXRhJGF1dG9QIiwiX21pZGRsZXdhcmVEYXRhJGF1dG9QMiIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUDMiLCJfbWlkZGxld2FyZURhdGEkYXV0b1A0IiwiX3BsYWNlbWVudHNTb3J0ZWRCeUxlIiwiZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIiwicGxhY2VtZW50cyIsIm92ZXJmbG93IiwiY3VycmVudEluZGV4IiwiaW5kZXgiLCJjdXJyZW50UGxhY2VtZW50IiwiY3VycmVudE92ZXJmbG93cyIsImFsbE92ZXJmbG93cyIsIm92ZXJmbG93cyIsIm5leHRQbGFjZW1lbnQiLCJwbGFjZW1lbnRzU29ydGVkQnlMZWFzdE92ZXJmbG93Iiwic2xpY2UiLCJzb3J0IiwiYSIsImIiLCJwbGFjZW1lbnRUaGF0Rml0c09uQWxsU2lkZXMiLCJmaW5kIiwiZXZlcnkiLCJyZXNldFBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZmxpcCIsIl9taWRkbGV3YXJlRGF0YSRmbGlwIiwiY2hlY2tNYWluQXhpcyIsImNyb3NzQXhpcyIsImNoZWNrQ3Jvc3NBeGlzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tTdHJhdGVneSIsImZsaXBBbGlnbm1lbnQiLCJpc0Jhc2VQbGFjZW1lbnQiLCJvdmVyZmxvd3NEYXRhIiwicHVzaCIsIl9taWRkbGV3YXJlRGF0YSRmbGlwJCIsIl9taWRkbGV3YXJlRGF0YSRmbGlwMiIsIm5leHRJbmRleCIsIl9vdmVyZmxvd3NEYXRhJG1hcCRzbyIsIm1hcCIsImQiLCJnZXRTaWRlT2Zmc2V0cyIsImlzQW55U2lkZUZ1bGx5Q2xpcHBlZCIsInNvbWUiLCJoaWRlIiwiX3RlbXAiLCJvZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuT2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbiIsImVzY2FwZWRPZmZzZXRzIiwiZXNjYXBlZCIsImNvbnZlcnRWYWx1ZVRvQ29vcmRzIiwibWFpbkF4aXNNdWx0aSIsImNyb3NzQXhpc011bHRpIiwicmF3VmFsdWUiLCJhbGlnbm1lbnRBeGlzIiwiZGlmZkNvb3JkcyIsImdldENyb3NzQXhpcyIsInNoaWZ0IiwibGltaXRlciIsIm1haW5BeGlzQ29vcmQiLCJjcm9zc0F4aXNDb29yZCIsIm1pblNpZGUiLCJtYXhTaWRlIiwibGltaXRlZENvb3JkcyIsImxpbWl0U2hpZnQiLCJyYXdPZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImxlbiIsImxpbWl0TWluIiwibGltaXRNYXgiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UyIiwiX21pZGRsZXdhcmVEYXRhJG9mZnNlMyIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZTQiLCJpc09yaWdpblNpZGUiLCJzaXplIiwiYXBwbHkiLCJoZWlnaHRTaWRlIiwid2lkdGhTaWRlIiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsImRpbWVuc2lvbnMiLCJhdmFpbGFibGVIZWlnaHQiLCJhdmFpbGFibGVXaWR0aCIsInByZXZEaW1lbnNpb25zIiwibmV4dERpbWVuc2lvbnMiLCJpbmxpbmUiLCJfYXdhaXQkcGxhdGZvcm0kZ2V0Q2wiLCJmYWxsYmFjayIsImNsaWVudFJlY3RzIiwiZ2V0Q2xpZW50UmVjdHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfY2xpZW50UmVjdHMkZmluZCIsImZpcnN0UmVjdCIsImxhc3RSZWN0IiwiaXNUb3AiLCJpc0xlZnRTaWRlIiwibWF4UmlnaHQiLCJtaW5MZWZ0IiwibWVhc3VyZVJlY3RzIiwicmVzZXRSZWN0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@floating-ui+core@0.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ })

};
;