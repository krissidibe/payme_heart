"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui+dom@0.5.4";
exports.ids = ["vendor-chunks/@floating-ui+dom@0.5.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@floating-ui+dom@0.5.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@floating-ui+dom@0.5.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/.pnpm/@floating-ui+core@0.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n\n\nfunction isWindow(value) {\n    return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n    if (node == null) {\n        return window;\n    }\n    if (!isWindow(node)) {\n        const ownerDocument = node.ownerDocument;\n        return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n}\nfunction getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n    return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.brands) {\n        return uaData.brands.map((item)=>item.brand + \"/\" + item.version).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n    return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n    return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n    return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    const OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle$1(element);\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n    // TODO: Try and use feature detection here instead\n    const isFirefox = /firefox/i.test(getUAString());\n    const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== \"none\" || css.perspective !== \"none\" || // @ts-ignore (TS 4.1 compat)\n    css.contain === \"paint\" || [\n        \"transform\",\n        \"perspective\"\n    ].includes(css.willChange) || isFirefox && css.willChange === \"filter\" || isFirefox && (css.filter ? css.filter !== \"none\" : false);\n}\nfunction isLayoutViewport() {\n    // Not Safari\n    return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n// • Always-visible scrollbar or not\n// • Width of <html>, etc.\n// const vV = win.visualViewport;\n// return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n    var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    let scaleX = 1;\n    let scaleY = 1;\n    if (includeScale && isHTMLElement(element)) {\n        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n    }\n    const win = isElement(element) ? getWindow(element) : window;\n    const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n    const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n    const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n    const width = clientRect.width / scaleX;\n    const height = clientRect.height / scaleY;\n    return {\n        width,\n        height,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x,\n        x,\n        y\n    };\n}\nfunction getDocumentElement(node) {\n    return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.pageXOffset,\n        scrollTop: element.pageYOffset\n    };\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction isScaled(element) {\n    const rect = getBoundingClientRect(element);\n    return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = {\n        x: 0,\n        y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n        if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n            scroll = getNodeScroll(offsetParent);\n        }\n        if (isHTMLElement(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent, true);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    return(// @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n    );\n}\nfunction getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n        return null;\n    }\n    return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n        currentNode = currentNode.host;\n    }\n    while(isHTMLElement(currentNode) && ![\n        \"html\",\n        \"body\"\n    ].includes(getNodeName(currentNode))){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else {\n            currentNode = currentNode.parentNode;\n        }\n    }\n    return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n    const window1 = getWindow(element);\n    let offsetParent = getTrueOffsetParent(element);\n    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\" && !isContainingBlock(offsetParent))) {\n        return window1;\n    }\n    return offsetParent || getContainingBlock(element) || window1;\n}\nfunction getDimensions(element) {\n    if (isHTMLElement(element)) {\n        return {\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    }\n    const rect = getBoundingClientRect(element);\n    return {\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { rect, offsetParent, strategy } = _ref;\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    if (offsetParent === documentElement) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = {\n        x: 0,\n        y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n        if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n            scroll = getNodeScroll(offsetParent);\n        }\n        if (isHTMLElement(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent, true);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n    }\n    return {\n        ...rect,\n        x: rect.x - scroll.scrollLeft + offsets.x,\n        y: rect.y - scroll.scrollTop + offsets.y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = getWindow(element);\n    const html = getDocumentElement(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const layoutViewport = isLayoutViewport();\n        if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n    var _element$ownerDocumen;\n    const html = getDocumentElement(element);\n    const scroll = getNodeScroll(element);\n    const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if (getComputedStyle$1(body || html).direction === \"rtl\") {\n        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if ([\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].includes(getNodeName(parentNode))) {\n        // @ts-ignore assume body is always available\n        return node.ownerDocument.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n    var _node$ownerDocument;\n    if (list === void 0) {\n        list = [];\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n    const win = getWindow(scrollableAncestor);\n    const target = isBody ? [\n        win\n    ].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n    const updatedList = list.concat(target);\n    return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));\n}\nfunction contains(parent, child) {\n    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    } else if (rootNode && isShadowRoot(rootNode)) {\n        let next = child;\n        do {\n            // use `===` replace node.isSameNode()\n            if (next && parent === next) {\n                return true;\n            } // @ts-ignore: need a better way to handle this...\n            next = next.parentNode || next.host;\n        }while (next);\n    }\n    return false;\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    return {\n        top,\n        left,\n        x: left,\n        y: top,\n        right: left + element.clientWidth,\n        bottom: top + element.clientHeight,\n        width: element.clientWidth,\n        height: element.clientHeight\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n    if (clippingParent === \"viewport\") {\n        return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getViewportRect(element, strategy));\n    }\n    if (isElement(clippingParent)) {\n        return getInnerBoundingClientRect(clippingParent, strategy);\n    }\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingAncestors(element) {\n    const clippingAncestors = getOverflowAncestors(element);\n    const canEscapeClipping = [\n        \"absolute\",\n        \"fixed\"\n    ].includes(getComputedStyle$1(element).position);\n    const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n        return [];\n    } // @ts-ignore isElement check ensures we return Array<Element>\n    return clippingAncestors.filter((clippingAncestors)=>isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n    const clippingAncestors = [\n        ...mainClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = max(rect.top, accRect.top);\n        accRect.right = min(rect.right, accRect.right);\n        accRect.bottom = min(rect.bottom, accRect.bottom);\n        accRect.left = max(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nconst platform = {\n    getClippingRect,\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    isElement,\n    getDimensions,\n    getOffsetParent,\n    getDocumentElement,\n    getElementRects: (_ref)=>{\n        let { reference, floating, strategy } = _ref;\n        return {\n            reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n            floating: {\n                ...getDimensions(floating),\n                x: 0,\n                y: 0\n            }\n        };\n    },\n    getClientRects: (element)=>Array.from(element.getClientRects()),\n    isRTL: (element)=>getComputedStyle$1(element).direction === \"rtl\"\n};\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll: _ancestorScroll = true, ancestorResize: _ancestorResize = true, elementResize = true, animationFrame = false } = options;\n    const ancestorScroll = _ancestorScroll && !animationFrame;\n    const ancestorResize = _ancestorResize && !animationFrame;\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...isElement(reference) ? getOverflowAncestors(reference) : [],\n        ...getOverflowAncestors(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    let observer = null;\n    if (elementResize) {\n        let initialUpdate = true;\n        observer = new ResizeObserver(()=>{\n            if (!initialUpdate) {\n                update();\n            }\n            initialUpdate = false;\n        });\n        isElement(reference) && !animationFrame && observer.observe(reference);\n        observer.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        var _observer;\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        (_observer = observer) == null ? void 0 : _observer.disconnect();\n        observer = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */ const computePosition = (reference, floating, options)=>(0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n        platform,\n        ...options\n    });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZsb2F0aW5nLXVpK2RvbUAwLjUuNC9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkY7QUFDbUM7QUFFOUgsU0FBU2EsU0FBU0MsS0FBSztJQUNyQixPQUFPQSxTQUFTQSxNQUFNQyxRQUFRLElBQUlELE1BQU1FLFFBQVEsSUFBSUYsTUFBTUcsS0FBSyxJQUFJSCxNQUFNSSxXQUFXO0FBQ3RGO0FBQ0EsU0FBU0MsVUFBVUMsSUFBSTtJQUNyQixJQUFJQSxRQUFRLE1BQU07UUFDaEIsT0FBT0M7SUFDVDtJQUVBLElBQUksQ0FBQ1IsU0FBU08sT0FBTztRQUNuQixNQUFNRSxnQkFBZ0JGLEtBQUtFLGFBQWE7UUFDeEMsT0FBT0EsZ0JBQWdCQSxjQUFjQyxXQUFXLElBQUlGLFNBQVNBO0lBQy9EO0lBRUEsT0FBT0Q7QUFDVDtBQUVBLFNBQVNJLG1CQUFtQkMsT0FBTztJQUNqQyxPQUFPTixVQUFVTSxTQUFTQyxnQkFBZ0IsQ0FBQ0Q7QUFDN0M7QUFFQSxTQUFTRSxZQUFZUCxJQUFJO0lBQ3ZCLE9BQU9QLFNBQVNPLFFBQVEsS0FBS0EsT0FBTyxDQUFDQSxLQUFLUSxRQUFRLElBQUksRUFBQyxFQUFHQyxXQUFXLEtBQUs7QUFDNUU7QUFFQSxTQUFTQztJQUNQLE1BQU1DLFNBQVNDLFVBQVVDLGFBQWE7SUFFdEMsSUFBSUYsVUFBVSxRQUFRQSxPQUFPRyxNQUFNLEVBQUU7UUFDbkMsT0FBT0gsT0FBT0csTUFBTSxDQUFDQyxHQUFHLENBQUNDLENBQUFBLE9BQVFBLEtBQUtDLEtBQUssR0FBRyxNQUFNRCxLQUFLRSxPQUFPLEVBQUVDLElBQUksQ0FBQztJQUN6RTtJQUVBLE9BQU9QLFVBQVVRLFNBQVM7QUFDNUI7QUFFQSxTQUFTQyxjQUFjM0IsS0FBSztJQUMxQixPQUFPQSxpQkFBaUJLLFVBQVVMLE9BQU80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U0FBU0E7UUFDUCxNQUFNQyxjQUFjL0gsc0JBQXNCb0c7UUFFMUMsSUFBSXlCLGVBQWdCRSxDQUFBQSxZQUFZL0csQ0FBQyxLQUFLNkcsWUFBWTdHLENBQUMsSUFBSStHLFlBQVkzRyxDQUFDLEtBQUt5RyxZQUFZekcsQ0FBQyxJQUFJMkcsWUFBWXBILEtBQUssS0FBS2tILFlBQVlsSCxLQUFLLElBQUlvSCxZQUFZbEgsTUFBTSxLQUFLZ0gsWUFBWWhILE1BQU0sR0FBRztZQUMvSzhGO1FBQ0Y7UUFFQWtCLGNBQWNFO1FBQ2RILFVBQVVJLHNCQUFzQkY7SUFDbEM7SUFFQW5CO0lBQ0EsT0FBTztRQUNMLElBQUlzQjtRQUVKZCxVQUFVQyxPQUFPLENBQUNDLENBQUFBO1lBQ2hCUixrQkFBa0JRLFNBQVNhLG1CQUFtQixDQUFDLFVBQVV2QjtZQUN6REksa0JBQWtCTSxTQUFTYSxtQkFBbUIsQ0FBQyxVQUFVdkI7UUFDM0Q7UUFDQ3NCLENBQUFBLFlBQVlULFFBQU8sS0FBTSxPQUFPLEtBQUssSUFBSVMsVUFBVUUsVUFBVTtRQUM5RFgsV0FBVztRQUVYLElBQUlOLGdCQUFnQjtZQUNsQmtCLHFCQUFxQlI7UUFDdkI7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUVELE1BQU1qTSxrQkFBa0IsQ0FBQ3lLLFdBQVdDLFVBQVVPLFVBQVloTCxrRUFBaUJBLENBQUN3SyxXQUFXQyxVQUFVO1FBQy9GSDtRQUNBLEdBQUdVLE9BQU87SUFDWjtBQUU2RCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLWNsaWVudC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZmxvYXRpbmctdWkrZG9tQDAuNS40L25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLm1qcz9iZWYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuXG5mdW5jdGlvbiBpc1dpbmRvdyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuZG9jdW1lbnQgJiYgdmFsdWUubG9jYXRpb24gJiYgdmFsdWUuYWxlcnQgJiYgdmFsdWUuc2V0SW50ZXJ2YWw7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICghaXNXaW5kb3cobm9kZSkpIHtcbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIHJldHVybiBpc1dpbmRvdyhub2RlKSA/ICcnIDogbm9kZSA/IChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogJyc7XG59XG5cbmZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcykge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChpdGVtID0+IGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbikuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBgU2hhZG93Um9vdGAgc3VwcG9ydFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1lcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICAvLyBUT0RPOiBUcnkgYW5kIHVzZSBmZWF0dXJlIGRldGVjdGlvbiBoZXJlIGluc3RlYWRcbiAgY29uc3QgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgLy8gQHRzLWlnbm9yZSAoVFMgNC4xIGNvbXBhdClcbiAgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmNsdWRlcyhjc3Mud2lsbENoYW5nZSkgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSk7XG59XG5mdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICAvLyBOb3QgU2FmYXJpXG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTsgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZm9yIHRoaXMgZmFpbHMgaW4gdmFyaW91cyB3YXlzXG4gIC8vIOKAoiBBbHdheXMtdmlzaWJsZSBzY3JvbGxiYXIgb3Igbm90XG4gIC8vIOKAoiBXaWR0aCBvZiA8aHRtbD4sIGV0Yy5cbiAgLy8gY29uc3QgdlYgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIC8vIHJldHVybiB2ViA/IE1hdGguYWJzKHdpbi5pbm5lcldpZHRoIC8gdlYuc2NhbGUgLSB2Vi53aWR0aCkgPCAwLjUgOiB0cnVlO1xufVxuXG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgdmFyIF93aW4kdmlzdWFsVmlld3BvcnQkbywgX3dpbiR2aXN1YWxWaWV3cG9ydCwgX3dpbiR2aXN1YWxWaWV3cG9ydCRvMiwgX3dpbiR2aXN1YWxWaWV3cG9ydDI7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgc2NhbGVYID0gMTtcbiAgbGV0IHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gIH1cblxuICBjb25zdCB3aW4gPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3c7XG4gIGNvbnN0IGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgY29uc3QgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyA/IChfd2luJHZpc3VhbFZpZXdwb3J0JG8gPSAoX3dpbiR2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW4kdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCkgIT0gbnVsbCA/IF93aW4kdmlzdWFsVmlld3BvcnQkbyA6IDAgOiAwKSkgLyBzY2FsZVg7XG4gIGNvbnN0IHkgPSAoY2xpZW50UmVjdC50b3AgKyAoYWRkVmlzdWFsT2Zmc2V0cyA/IChfd2luJHZpc3VhbFZpZXdwb3J0JG8yID0gKF93aW4kdmlzdWFsVmlld3BvcnQyID0gd2luLnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbiR2aXN1YWxWaWV3cG9ydDIub2Zmc2V0VG9wKSAhPSBudWxsID8gX3dpbiR2aXN1YWxWaWV3cG9ydCRvMiA6IDAgOiAwKSkgLyBzY2FsZVk7XG4gIGNvbnN0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgY29uc3QgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICByZXR1cm4gKChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQucGFnZVhPZmZzZXQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnBhZ2VZT2Zmc2V0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuZnVuY3Rpb24gaXNTY2FsZWQoZWxlbWVudCkge1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuICByZXR1cm4gcm91bmQocmVjdC53aWR0aCkgIT09IGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgcm91bmQocmVjdC5oZWlnaHQpICE9PSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgLy8gQHRzLWlnbm9yZSAtIGNoZWNrZWQgYWJvdmUgKFRTIDQuMSBjb21wYXQpXG4gIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIGlzU2NhbGVkKG9mZnNldFBhcmVudCksIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBub2RlLmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIG5vZGUucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KG5vZGUpID8gbm9kZS5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIGdldERvY3VtZW50RWxlbWVudChub2RlKSAvLyBmYWxsYmFja1xuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFbJ2h0bWwnLCAnYm9keSddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkpIHtcbiAgICBpZiAoaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuXG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSAvLyBUaGlzIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIG5lZWQgdG8gYmUgbmVnYXRlZC5cbiAgICAvLyBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAvLyAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICAvLyB9XG5cbiAgfVxuXG4gIHJldHVybiB7IC4uLnJlY3QsXG4gICAgeDogcmVjdC54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKyBvZmZzZXRzLngsXG4gICAgeTogcmVjdC55IC0gc2Nyb2xsLnNjcm9sbFRvcCArIG9mZnNldHMueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAhbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgY29uc3QgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlJDEoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUobm9kZSk7XG5cbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKHBhcmVudE5vZGUpKSkge1xuICAgIC8vIEB0cy1pZ25vcmUgYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IocGFyZW50Tm9kZSk7XG59XG5cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBjb25zdCB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10pIDogc2Nyb2xsYWJsZUFuY2VzdG9yO1xuICBjb25zdCB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vIEB0cy1pZ25vcmU6IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyh0YXJnZXQpKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICBjb25zdCByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcblxuICAgIGRvIHtcbiAgICAgIC8vIHVzZSBgPT09YCByZXBsYWNlIG5vZGUuaXNTYW1lTm9kZSgpXG4gICAgICBpZiAobmV4dCAmJiBwYXJlbnQgPT09IG5leHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIEB0cy1pZ25vcmU6IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgfSB3aGlsZSAobmV4dCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB4OiBsZWZ0LFxuICAgIHk6IHRvcCxcbiAgICByaWdodDogbGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgYm90dG9tOiB0b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICB3aWR0aDogZWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgaWYgKGNsaXBwaW5nUGFyZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSk7XG4gIH1cblxuICBpZiAoaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSkge1xuICAgIHJldHVybiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICB9XG5cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nQW5jZXN0b3JzKGVsZW1lbnQpIHtcbiAgY29uc3QgY2xpcHBpbmdBbmNlc3RvcnMgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50KTtcbiAgY29uc3QgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5jbHVkZXMoZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uKTtcbiAgY29uc3QgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gQHRzLWlnbm9yZSBpc0VsZW1lbnQgY2hlY2sgZW5zdXJlcyB3ZSByZXR1cm4gQXJyYXk8RWxlbWVudD5cblxuXG4gIHJldHVybiBjbGlwcGluZ0FuY2VzdG9ycy5maWx0ZXIoY2xpcHBpbmdBbmNlc3RvcnMgPT4gaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3JzKSAmJiBjb250YWlucyhjbGlwcGluZ0FuY2VzdG9ycywgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nQW5jZXN0b3JzKSAhPT0gJ2JvZHknKTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgbWFpbkNsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0FuY2VzdG9ycyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLm1haW5DbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgaXNFbGVtZW50LFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0RWxlbWVudFJlY3RzOiBfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgcmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmcsXG4gICAgICBzdHJhdGVneVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgICAgZmxvYXRpbmc6IHsgLi4uZ2V0RGltZW5zaW9ucyhmbG9hdGluZyksXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXRDbGllbnRSZWN0czogZWxlbWVudCA9PiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSksXG4gIGlzUlRMOiBlbGVtZW50ID0+IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnXG59O1xuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsOiBfYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplOiBfYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0cnVlLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGFuY2VzdG9yU2Nyb2xsID0gX2FuY2VzdG9yU2Nyb2xsICYmICFhbmltYXRpb25GcmFtZTtcbiAgY29uc3QgYW5jZXN0b3JSZXNpemUgPSBfYW5jZXN0b3JSZXNpemUgJiYgIWFuaW1hdGlvbkZyYW1lO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4oaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcblxuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIGxldCBpbml0aWFsVXBkYXRlID0gdHJ1ZTtcbiAgICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICBpZiAoIWluaXRpYWxVcGRhdGUpIHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBpc0VsZW1lbnQocmVmZXJlbmNlKSAmJiAhYW5pbWF0aW9uRnJhbWUgJiYgb2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2UpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICB9XG5cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuXG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJhbWVMb29wKCkge1xuICAgIGNvbnN0IG5leHRSZWZSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSk7XG5cbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG5cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuXG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfb2JzZXJ2ZXI7XG5cbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KTtcbiAgICAoX29ic2VydmVyID0gb2JzZXJ2ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIG9ic2VydmVyID0gbnVsbDtcblxuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSByZWZlcmVuY2UgZWxlbWVudCB3aGVuIGl0IGlzIGdpdmVuIGEgY2VydGFpbiBDU1MgcG9zaXRpb25pbmdcbiAqIHN0cmF0ZWd5LlxuICovXG5cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiBjb21wdXRlUG9zaXRpb24kMShyZWZlcmVuY2UsIGZsb2F0aW5nLCB7XG4gIHBsYXRmb3JtLFxuICAuLi5vcHRpb25zXG59KTtcblxuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9O1xuIl0sIm5hbWVzIjpbInJlY3RUb0NsaWVudFJlY3QiLCJjb21wdXRlUG9zaXRpb24iLCJjb21wdXRlUG9zaXRpb24kMSIsImFycm93IiwiYXV0b1BsYWNlbWVudCIsImRldGVjdE92ZXJmbG93IiwiZmxpcCIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwib2Zmc2V0Iiwic2hpZnQiLCJzaXplIiwiaXNXaW5kb3ciLCJ2YWx1ZSIsImRvY3VtZW50IiwibG9jYXRpb24iLCJhbGVydCIsInNldEludGVydmFsIiwiZ2V0V2luZG93Iiwibm9kZSIsIndpbmRvdyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUkMSIsImVsZW1lbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0VUFTdHJpbmciLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwibWFwIiwiaXRlbSIsImJyYW5kIiwidmVyc2lvbiIsImpvaW4iLCJ1c2VyQWdlbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiaXNOb2RlIiwiTm9kZSIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJPd25FbGVtZW50IiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInRlc3QiLCJpc1RhYmxlRWxlbWVudCIsImluY2x1ZGVzIiwiaXNDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZmlsdGVyIiwiaXNMYXlvdXRWaWV3cG9ydCIsIm1pbiIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsIl93aW4kdmlzdWFsVmlld3BvcnQkbyIsIl93aW4kdmlzdWFsVmlld3BvcnQiLCJfd2luJHZpc3VhbFZpZXdwb3J0JG8yIiwiX3dpbiR2aXN1YWxWaWV3cG9ydDIiLCJjbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0V2lkdGgiLCJ3aWR0aCIsIm9mZnNldEhlaWdodCIsImhlaWdodCIsIndpbiIsImFkZFZpc3VhbE9mZnNldHMiLCJ4IiwibGVmdCIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0TGVmdCIsInkiLCJ0b3AiLCJvZmZzZXRUb3AiLCJyaWdodCIsImJvdHRvbSIsImdldERvY3VtZW50RWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJpc1NjYWxlZCIsInJlY3QiLCJnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsInN0cmF0ZWd5IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJzY3JvbGwiLCJvZmZzZXRzIiwib2Zmc2V0UmVjdCIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9zaXRpb24iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldE9mZnNldFBhcmVudCIsImdldERpbWVuc2lvbnMiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJnZXRWaWV3cG9ydFJlY3QiLCJodG1sIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJsYXlvdXRWaWV3cG9ydCIsImdldERvY3VtZW50UmVjdCIsIl9lbGVtZW50JG93bmVyRG9jdW1lbiIsImJvZHkiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yIiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJsaXN0IiwiX25vZGUkb3duZXJEb2N1bWVudCIsInNjcm9sbGFibGVBbmNlc3RvciIsImlzQm9keSIsInRhcmdldCIsImNvbmNhdCIsInVwZGF0ZWRMaXN0IiwiY29udGFpbnMiLCJwYXJlbnQiLCJjaGlsZCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJuZXh0IiwiZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1BhcmVudCIsImdldENsaXBwaW5nQW5jZXN0b3JzIiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJyZWR1Y2UiLCJhY2NSZWN0IiwiY2xpcHBpbmdBbmNlc3RvciIsInBsYXRmb3JtIiwiZ2V0RWxlbWVudFJlY3RzIiwicmVmZXJlbmNlIiwiZmxvYXRpbmciLCJnZXRDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImlzUlRMIiwiYXV0b1VwZGF0ZSIsInVwZGF0ZSIsIm9wdGlvbnMiLCJhbmNlc3RvclNjcm9sbCIsIl9hbmNlc3RvclNjcm9sbCIsImFuY2VzdG9yUmVzaXplIiwiX2FuY2VzdG9yUmVzaXplIiwiZWxlbWVudFJlc2l6ZSIsImFuaW1hdGlvbkZyYW1lIiwiYW5jZXN0b3JzIiwiZm9yRWFjaCIsImFuY2VzdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJvYnNlcnZlciIsImluaXRpYWxVcGRhdGUiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJmcmFtZUlkIiwicHJldlJlZlJlY3QiLCJmcmFtZUxvb3AiLCJuZXh0UmVmUmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9vYnNlcnZlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@floating-ui+dom@0.5.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ })

};
;